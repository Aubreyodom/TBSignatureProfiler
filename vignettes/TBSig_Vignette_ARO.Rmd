---
title: "TBSignatureProfiler Vignette"
author: "Aubrey Odom"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
    theme: "flatly"
editor_options: 
  chunk_output_type: console
vignette: >
  %\VignetteIndexEntry{TBSignatureProfiler Tutorial}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      collapse = TRUE,
                      comment = "#>")
suppressPackageStartupMessages({
  library(SummarizedExperiment)
  library(DESeq2)
  library(edgeR)
  library(DT)
  library(ROCR)
})
```


## The SummarizedExperiment Object
The TBSignatureProfiler functions on and interacts with a SummarizedExperiment object. This is an amazing data structure that is being generated by the Bioconductor team. The package description is found [here](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html), and their documentation is found [here](https://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html). 


Quoting their documentation: "The SummarizedExperiment container contains one or more assays, each represented by a matrix-like object of numeric or other mode. The rows typically represent genomic ranges [genes] of interest and the columns represent samples."

"The SummarizedExperiment class is used to store rectangular matrices of experimental results, which are commonly produced by sequencing and microarray experiments. Each object stores observations of one or more samples, along with additional meta-data describing both the observations (features) and samples (phenotypes)."

"A key aspect of the SummarizedExperiment class is the coordination of the meta-data [colData] and assays when subsetting. For example, if you want to exclude a given sample you can do for both the meta-data and assay in one operation, which ensures the meta-data and observed data will remain in sync. Improperly accounting for meta and observational data has resulted in a number of incorrect results and retractions so this is a very desirable property."


To install the SummarizedExperiment package, run the following code:
```{r SE install, eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("SummarizedExperiment")
```

The TBSignature profiler will input a SummarizedExperiment object, and accordingly output a SummarizedExperiment object with the signature scores stored in the colData. 

## Read in Data and Generate a SummarizedExperiment
The following code will read in the data count matrix (assay) and sample meta data (colData). It will also generate additional assays, namely the logcounts, counts per million (CPM) reads mapped, and logCPM assays. 


```{r loading data}
## HIV/TB gene expression data for 25,369 genes and 33 samples
counts <- read.table("inst/extdata/features_combined.txt",
                     header = T, row.names = 1, sep = '\t')

## Sample information file for the 33 samples containing the sample name and TB status
coldata <- read.table("inst/extdata/meta_data.txt", header = T, 
                      row.names = 1)

### Generate a Summarized experiment object
hivtb_data_all <- SummarizedExperiment(
  assays = list(counts = as.matrix(counts)), colData = coldata)

### Note that we have 25,369 genes, 33 samples, and 1 assay 
dim(hivtb_data_all)
assays(hivtb_data_all)

### Subset the data to remove all 2 Anti-Retroviral Therapy samples
hivtb_data <- hivtb_data_all[, hivtb_data_all$Disease != "tb_hiv_art"]
dim(hivtb_data)

### Update the factor class
hivtb_data$Disease <- factor(hivtb_data$Disease)

### Make an additional binary indicator
hivtb_data$BinaryTB <- as.numeric(hivtb_data$Disease)-1
```

## Add Assays and Subset the SummarizedExperiment
The SummarizedExperiment object allows for the generation, storage and easy subsetting of your data.

```{r}
## Make a logcounts assay
assay(hivtb_data, "logcounts") <- log(assays(hivtb_data)$counts + 1)

## Make CPM assay using the edgeR package
hivtb_data.norm <- DGEList(counts = assay(hivtb_data, "counts"))
dge_hivtb_data.norm <- calcNormFactors(hivtb_data.norm)
CPM_hivtb_data.norm <- cpm(dge_hivtb_data.norm, log = FALSE, 
                           prior.counts = 3)
assay(hivtb_data, "cpm") <- CPM_hivtb_data.norm

## Make logCPM also using the edgeR package
logCPM_hivtb_data.norm <- cpm(dge_hivtb_data.norm, log = TRUE, prior.counts = 3)
assay(hivtb_data, "logcpm") <- logCPM_hivtb_data.norm
rm(hivtb_data.norm, dge_hivtb_data.norm, logCPM_hivtb_data.norm)

### Note that we now have 4 assays
assays(hivtb_data)
```

## SignatureProfiler {.tabset}

Download the TBSigantureProfiler using the following command:

```{r load profiler, eval = FALSE}
devtools::install_github("compbiomed/TBSignatureProfiler")
```


```{r, message = FALSE, results = 'hide'}
library(TBSignatureProfiler)

## List all 34 signatures in the profiler
names(TBsignatures)

## We can use all of these signatures for further analysis
siglist_hivtb <- names(TBsignatures)
TBsignatures_nanostring <- TBsignatures[siglist_hivtb]

## Run the TBSignatureProfiler to score the signatures in the data
ssgsea_res <- runTBsigProfiler(hivtb_data, useAssay = "logcpm",
                                 signatures = TBsignatures_nanostring,
                                 algorithm = "ssGSEA",
                                 combineSigAndAlgorithm = FALSE,
                                 parallel.sz = 4)
```


The TBSignature profiler will input a SummarizedExperiment object, and output a SummarizedExperiment object with the signature scores stored in the colData. For example:

```{r, message = FALSE, results = 'hide'}
## colData from the original SE
colData(hivtb_data)

## colData from the the SE from the Profiler
colData(ssgsea_res)
```

## SignatureProfiler Plots{.tabset}

### All Signatures Heatmap
The TBSignatureProfiler includes the functionality to create heatmaps from the created SE object. The columns of the heatmaps are the samples, and the rows are the signatures.

```{r heat_ssgsea, message = FALSE, fig.height = 8, fig.width = 10}
signatureHeatmap(ssgsea_res, name = "Heatmap of Signatures, 
                 ssGSEA Algorithm", 
                 signatureColNames = names(TBsignatures_nanostring),
                 annotationColNames = "Disease",
                 scale = TRUE,
                 showColumnNames = FALSE)
```


### All Signatures Boxplots

```{r boxssgsea, message = FALSE, results = 'hide', fig.height = 9, fig.width=12}
signatureBoxplot(ssgsea_res, name = "Boxplots of Signatures, ssGSEA", 
                 signatureColNames = names(TBsignatures_nanostring),
                 annotationColName = "Disease", rotateLabels = FALSE)
```


### Single Boxplots from one Signature at a Time {.tabset}

```{r Boxplots_single_ssgsea, results = "asis"}
for (i in names(TBsignatures_nanostring)){

  cat("####", i, "\n")

  print(signatureBoxplot(ssgsea_res, name = i, signatureColNames = i,
                 annotationColName = c("Disease")))
  
  cat("\n\n")
}

```

### Individual Gene Signature plots {.tabset}
The same function used previously can also produce heatmaps that highlight a single selected signature. In these heatmaps, the columns of the heatmaps are the samples as before, whereas the rows are now the genes included in the signatures.

```{r genes_ssgsea, results = "asis"}
for (i in names(TBsignatures_nanostring)){

  cat("####", i, "\n")

  signatureGeneHeatmap(ssgsea_res, useAssay = "logcpm", 
                     TBsignatures_nanostring[[i]],
                     name = i, signatureColNames = i, 
                     annotationColNames = c("Disease"),
                     showColumnNames = FALSE)
  
  cat("\n\n")
}

```


## WISHLIST {.tabset}

```{r SigEVAL}
## We can normalize the data and evaluate the signatures
hivtb_norm <- deseq2_norm_rle(assay(hivtb_data, "counts"))
quantitative.result <- SignatureQuantitative(hivtb_norm,
                      colData(hivtb_data)$BinaryTB,
                      TBsignatures,
                      names(TBsignatures),
                      num.boot = 5)

## Order by area under the curve. Note that Esmail...893
## and Walter---51 are the best here
ordered_AUC <- quantitative.result$df.auc.ci[order(
  quantitative.result$df.auc.ci$`Estimate`, decreasing = TRUE),]
ordered_AUC
```

### Table with T-tests & AUC 
```{r AUC table}

pvals <- aucs <- aucs_boot <- NULL
TB_status <- ssgsea_res$Disease
for (i in names(TBsignatures_nanostring)){
  score <- colData(ssgsea_res)[i][,1]
  pvals <- c(pvals, t.test(score ~ TB_status)$p.value)
  pred <- prediction(score, TB_status)
  perf <- performance(pred, "tpr", "fpr")
  auc <- performance(pred,"auc")@'y.values'[[1]]
  aucs <- c(aucs, max(auc, 1 - auc))
  
  tmp_aucs <- NULL
    for (j in 1:100){
    index <- sample(1:length(score), replace = T)
    tmp_score <- score[index]
    tmp_TB_status <- TB_status[index]
    pred <- prediction(tmp_score, tmp_TB_status)
    perf <- performance(pred, "tpr", "fpr")
    tmp_auc <- performance(pred, "auc")@'y.values'[[1]]
    tmp_auc <- max(tmp_auc, 1 - tmp_auc)
    tmp_aucs <- c(tmp_aucs, tmp_auc)
  }
  aucs_boot = cbind(aucs_boot, tmp_aucs)
}

datatable(cbind("Signatures" = names(TBsignatures_nanostring), 
                "P-values" = pvals, 
                "-10Log(p-values)" = round(-10 * log(pvals), 4), 
                "LowerAUC" = round(apply(aucs_boot, 2, quantile, probs = .05), 4), 
                "AUCs" = round(aucs, 4), 
                "UpperAUC"= round(apply(aucs_boot, 2, quantile, probs = .95), 4)
                )[order(aucs, decreasing = T),], 
          options = list(scrollX = T, pageLength = 30), rownames = F)

```


### Boxplots for the bootstrapped AUCs
Note that this boxplot and the previous table both need bootstrapped AUCs (only need to write one bootstrapping function??)
```{r }

pvals <- aucs <- aucs_boot <- NULL
TB_status <- ssgsea_res$Disease
for (i in names(TBsignatures_nanostring)){
  score <- colData(ssgsea_res)[i][,1]
  pvals <- c(pvals, t.test(score~TB_status)$p.value)
  
  pred <- prediction(score, TB_status)
  perf <- performance(pred,"tpr","fpr")
  auc <- performance(pred,"auc")@'y.values'[[1]]
  aucs <- c(aucs, max(auc,1-auc))
  
  tmp_aucs <- NULL
    for (j in 1:100){
    index <- sample(1:length(score), replace = T)
    tmp_score <- score[index]
    tmp_TB_status <- TB_status[index]
    pred <- prediction(tmp_score, tmp_TB_status)
    perf <- performance(pred,"tpr","fpr")
    tmp_auc <- performance(pred,"auc")@'y.values'[[1]]
    tmp_auc <- max(tmp_auc, 1-tmp_auc)
    tmp_aucs <- c(tmp_aucs, tmp_auc)
  }
  aucs_boot <- cbind(aucs_boot, tmp_aucs)
}

colnames(aucs_boot) <- names(TBsignatures_nanostring)
boxplot(aucs_boot[,order(aucs)], las = 2, cex.axis = 0.7, cex = 0.25,
        main = "Boxplot Comparison of Signatures")
abline(h = 0.5, col = 2, lty = 2)

```


### AUC plots {.tabset}
I am using the ROCR package, but this needs to be updated! Also note that this makes AUC plot separately, can I get an array of ROCs for all the signatures (similar to the signatureBoxplots function?? i.e. make an analogous signatureAUCs function??)

```{r, results = 'asis'}
TB_status <- ssgsea_res$Disease

for (i in names(TBsignatures_nanostring)){
  scores <- colData(ssgsea_res)[[i]]
  pred <- prediction(scores, TB_status)
  perf <- performance(pred,"tpr","fpr")
  auc <- performance(pred,"auc")@'y.values'[[1]]
  auc <- max(auc, 1-auc)
  
  cat("####", i, "\n")

  plot(perf)
  title("ROC Curve") 
  text(.6,.2, paste("AUC:",round(auc,3)))

  cat("\n\n")
}


```