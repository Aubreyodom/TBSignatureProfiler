---
title: "TBSignatureProfiler Vignette"
author: "Evan Johnson & Aubrey Odom"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
    theme: "flatly"
editor_options: 
  chunk_output_type: console
vignette: >
  %\VignetteIndexEntry{TBSignatureProfiler Tutorial}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      collapse = TRUE,
                      comment = "#>")
suppressPackageStartupMessages({
  library(knitr)
})
```

## A Brief Introduction to the TBSignatureProfiler

## SummarizedExperiment 
The TBSignatureProfiler functions on and interacts with a SummarizedExperiment object. This is an amazing data structure that is being generated by the Bioconductor team. The package description is found [here](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html), and their documentation is found [here](https://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html). A basic understanding of the SummarizedExperiment object and its properties is necessary to use the TBSignatureProfiler package.


To install the SummarizedExperiment package, run the following code:
```{r SE install, eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("SummarizedExperiment")
```

The TBSignature profiler will input a SummarizedExperiment object, and accordingly output a SummarizedExperiment object with the signature scores stored in the colData. 

Download the TBSignatureProfiler using the following command:

```{r load profiler, eval = FALSE, results = FALSE}
devtools::install_github("aubreyodom/TBSignatureProfiler")
```

## Read in Data and Generate a SummarizedExperiment
The following code will read in the data count matrix (assay) and sample meta data (colData). It will also generate additional assays, namely the logcounts, counts per million (CPM) reads mapped, and logCPM assays. 

```{r setup, include = FALSE}
suppressPackageStartupMessages({
  library(SummarizedExperiment)
library(TBSignatureProfiler)
})
```

IN this tutorial, we will work with HIV and Tuberculosis (TB) gene expression data in a SummarizedExperiment format. This dataset is included in the TBSignatureProfiler package.

```{r loading data}

## HIV/TB gene expression data for 25,369 genes and 33 samples
hivtb_data_all <- TB_hiv

### Note that we have 25,369 genes, 33 samples, and 1 assay of counts
dim(hivtb_data_all)
assays(hivtb_data_all)

### Subset the data to remove the 2 Anti-Retroviral Therapy samples
hivtb_data <- hivtb_data_all[, hivtb_data_all$Disease != "tb_hiv_art"]
hivtb_data$Disease <- factor(hivtb_data$Disease)
dim(hivtb_data)

### Make an additional binary indicator for signature evaluation
hivtb_data$BinaryTB <- as.numeric(hivtb_data$Disease)-1
```

## Add Assays and Subset the SummarizedExperiment
The SummarizedExperiment object allows for the generation, storage and easy subsetting of your data.

```{r Add assays}
## Make a logcounts, CPM and logCPM assay
hivtb_data <- mkAssay(SE_obj = hivtb_data)

### Note that we now have 4 assays
assays(hivtb_data)
```

## SignatureProfiler {.tabset}

The TBSignatureProfiler enables comparison of multiple Tuberculosis gene signatures that have been published in literature. The package provides 34 signatures for comparison across a given dataset.

```{r, message = FALSE, results = 'hide'}

## List all 34 signatures in the profiler
names(TBsignatures)

## We can use all of these signatures for further analysis
siglist_hivtb <- names(TBsignatures)
TBsignatures_nanostring <- TBsignatures[siglist_hivtb]

## Run the TBSignatureProfiler to score the signatures in the data
ssgsea_res <- runTBsigProfiler(input = hivtb_data, 
                               useAssay = "logcpm",
                               signatures = TBsignatures_nanostring,
                               algorithm = "ssGSEA",
                               combineSigAndAlgorithm = FALSE,
                               parallel.sz = 4)
```


The TBSignature profiler will input a SummarizedExperiment object, and output a SummarizedExperiment object with the signature scores stored in the colData. A truncated example of this is provided here:

```{r, message = FALSE}
## colData from the original SE
head(colData(hivtb_data))

## colData from the the SE from the Profiler
head(colData(ssgsea_res))[1:5]
```

## SignatureProfiler Plots{.tabset}

### All Signatures Heatmap
The TBSignatureProfiler includes the functionality to create heatmaps from the created SE object. The columns of the heatmaps are the samples, and the rows are the signatures.

```{r heat_ssgsea, message = FALSE, fig.height = 8, fig.width = 10}
signatureHeatmap(ssgsea_res, name = "Heatmap of Signatures, 
                 ssGSEA Algorithm", 
                 signatureColNames = names(TBsignatures_nanostring),
                 annotationColNames = "Disease",
                 scale = TRUE,
                 showColumnNames = FALSE)
```


### All Signatures Boxplots
Points represent the jittered scores for each sample. 
```{r boxssgsea, message = FALSE, results = 'hide', fig.height = 9, fig.width=12}
signatureBoxplot(inputData = ssgsea_res, 
                 name = "Boxplots of Signatures, ssGSEA", 
                 signatureColNames = names(TBsignatures_nanostring),
                 annotationColName = "Disease", rotateLabels = FALSE)
```


### Single Boxplots from one Signature at a Time {.tabset}

```{r Boxplots_single_ssgsea, results = "asis", message = FALSE}
for (i in names(TBsignatures_nanostring)){

  cat("####", i, "\n")

  print(signatureBoxplot(ssgsea_res, name = i, signatureColNames = i,
                 annotationColName = c("Disease")))
  
  cat("\n\n")
}

```

### Individual Gene Signature plots {.tabset}
The same function used previously can also produce heatmaps that highlight a single selected signature. In these heatmaps, the columns of the heatmaps are the samples as before, whereas the rows are now the genes included in the signatures.

```{r genes_ssgsea, results = "asis", message = FALSE}
for (i in names(TBsignatures_nanostring)){

  cat("####", i, "\n")

  signatureGeneHeatmap(inputData = ssgsea_res, useAssay = "logcpm",
                       TBsignatures_nanostring[[i]],
                       name = i, signatureColNames = i, 
                       annotationColNames = c("Disease"),
                       showColumnNames = FALSE)
  
  cat("\n\n")
}

```

### Table with T-tests & AUC 
```{r AUC table, message = FALSE}
tableAUC(SE_scored = ssgsea_res, 
         annotationData = ssgsea_res$Disease, 
         signatureColNames = TBsignatures_nanostring,
         num.boot = 100, 
         pb_show = FALSE)
```

### Boxplots for the bootstrapped AUCs
```{r BS Boxplots, message = FALSE}
compareBoxplots(ssgsea_res, ssgsea_res$Disease,             
                TBsignatures_nanostring, pb_show = FALSE)
```


### Separate AUC plots {.tabset}
```{r AUC plots, results = 'asis', message = FALSE}
for (i in names(TBsignatures_nanostring)){
  
  cat("####", i, "\n")
  
  signatureROCplot(inputData = ssgsea_res, 
                   signatureColNames = i,
                   annotationColName = "Disease",
                   annotationData = ssgsea_res$Disease)
  
  cat("\n\n")
}
```

### AUC plots for all signatures
Currently when I run this function with all signatures it spits them out one at a time, but I want them to print out on one page.
```{r SUCssgsea, message = FALSE, fig.height = 9, fig.width = 12}

  signatureROCplot(inputData = ssgsea_res,
                 annotationData = ssgsea_res$Disease,
                 signatureColNames = names(TBsignatures_nanostring),
                 annotationColName = "Disease")

```

## Signature Evaluation with Logistic Regression
For this dataset, we wish to differentiate HIV/Tuberculosis samples from HIV-only samples. In order to evaluate how the 34 provided TB signatures do this, we use each signature and our 31-sample dataset.

During the training process, we bootstrap the samples, cross-validate the logistic regression and calculate the validation set AUCs from each cross-validation iteration In theory, if a signature is a good one, it should have a higher average AUC from these bootstrap logistic regression experiments. We then provide the AUC boxplot for each signature, which provides a clear comparison between the signatures. 

```{r SigEVAL, message = FALSE}
## We can normalize the data and evaluate the signatures
hivtb_norm <- deseq2_norm_rle(assay(hivtb_data, "counts"))

quantitative.result <- SignatureQuantitative(df.input = hivtb_norm,
                       target.vec.num = colData(hivtb_data)$BinaryTB,
                       signature.list = TBsignatures,
                       signature.name.vec = names(TBsignatures),
                       num.boot = 10,
                       pb.show = FALSE)

kable(head(quantitative.result$df.auc.ci), digits = 4)
kable(head(quantitative.result$df.sensitivity.ci), digits = 4)
kable(head(quantitative.result$df.specificity.ci), digits = 4)

## Order by area under the curve.
ordered_AUC <- quantitative.result$df.auc.ci[order(
  quantitative.result$df.auc.ci$`Estimate`, decreasing = TRUE),]
kable(head(ordered_AUC), digits = 4)

```
