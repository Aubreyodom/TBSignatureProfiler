---
title: "TBSignatureProfiler Vignette"
author: "Aubrey Odom & Evan Johnson"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
    theme: "flatly"
editor_options: 
  chunk_output_type: console
vignette: >
  %\VignetteIndexEntry{TBSignatureProfiler Tutorial}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r knitr setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      collapse = TRUE,
                      comment = "#>")
```

# A Brief Introduction to the TBSignatureProfiler

The TBSignatureProfiler is an R package to compare the performance of various published gene signatures in distinguishing Tuberculosis-diseased cells from those in other states (e.g. HIV, Pneumonia, latent Tuberculosis) on any provided gene expression dataset. It is our objective to consistently update this package with additional signatures as they become published, and possibly add functionality to evaluate signatures for other pathogenic diseases in the near future. 

In order to install the TBSignatureProfiler, run the following code:

```{r load profiler, eval = FALSE, results = FALSE}
devtools::install_github("aubreyodom/TBSignatureProfiler")
```

## Compatability with SummarizedExperiment objects
While the TBSignatureProfiler often allows for the form of a `data.frame` or `matrix` as input data, the most ideal form of input for this package is that of the `SummarizedExperiment` object. This is an amazing data structure that is being developed by the Bioconductor team. It allows for additional information to be attached to the main data object without taking up additional rows or columns in the frame, which is exceptionally helpful when dealing with gene expression data. To learn more about proper usage and context of the `SummarizedExperiment` object, you may want to take a look at the [package description](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html) and [package vignette](https://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html). A basic understanding of the `assay` and `colData` properties of a `SummarizedExperiment` will be useful for the purposes of this vignette.


To install the `SummarizedExperiment` package, run the following code:
```{r SE install, eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("SummarizedExperiment")
```


# A Tutorial for the TBSignature Profiler

```{r setup, include = FALSE}
suppressPackageStartupMessages({
  library(SummarizedExperiment)
  library(TBSignatureProfiler)
})
```

## Loading the dataset
In this tutorial, we will work with HIV and Tuberculosis (TB) gene expression data in a `SummarizedExperiment` format. This dataset is included in the TBSignatureProfiler package and can be loaded into the global environment with `data("TB_hiv")`. THe 31 samples in the dataset are marked as either having both TB and HIV infection, or HIV infection only.

We begin by examining the dataset, which contains a matrix of counts information (an "assay" in SummarizedExperiment terms) and another matrix of meta data information on our samples (the "colData"). We will also generate a few additional assays; therse are the log(counts), the counts per million (CPM) reads mapped, and the log(CPM) assays. 

```{r loading data}

## HIV/TB gene expression data, included in the package
hivtb_data <- TB_hiv

### Note that we have 25,369 genes, 33 samples, and 1 assay of counts
dim(hivtb_data)
assays(hivtb_data)

```

```{r add assays}
## Make a logcounts, CPM and logCPM assay
hivtb_data <- mkAssay(hivtb_data, log = TRUE, counts_to_CPM = TRUE)

### Check to see that we now have 4 assays
assays(hivtb_data)
```

## Using the SignatureProfiler {.tabset}

The TBSignatureProfiler enables comparison of multiple Tuberculosis gene signatures. The package currently contains information on 34 signatures for comparison. With the `runTBSigProfiler` function, we are able to score these signatures with a selection of algorithms, including [gene set variation analysis](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-14-7) (GSVA) (HÃ¤nzelmann et al, 2013), [single-sample GSEA](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-14-7) (ssGSEA) (Barbie et al, 2009), and the [ASSIGN](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-14-7) pathway profiling toolkit (Shen et al, 2015).

Here, we opt to evaluate all signatures included in the package with ssGSEA. Paraphrasing from the [ssGSEA documentation](http://software.broadinstitute.org/cancer/software/genepattern/modules/docs/ssGSEAProjection/4), for each pairing of one of the 31 samples and its gene set, ssGSEA calculates a seperate enrichment score independent of the phenotypic labeling (in this case, whether a sample has HIV/TB, or HIV only). The single sample's gene expression profile is then transformed to a gene set enrichment profile. A score from the set profile represents the activity level of the biological process in which the gene set's members are coordinately up- or down-regulated.  

```{r run profiler, message = FALSE, results = 'hide'}

## List all 34 signatures in the profiler
names(TBsignatures)

## We can use all of these signatures for further analysis
siglist_hivtb <- names(TBsignatures)

## Run the TBSignatureProfiler to score the signatures in the data
ssgsea_result <- runTBsigProfiler(input = hivtb_data, 
                               useAssay = "logcpm",
                               signatures = TBsignatures,
                               algorithm = "ssGSEA",
                               combineSigAndAlgorithm = TRUE,
                               parallel.sz = 4)
```

When a `SummarizedExperiment` is the format of the input data for `runTBsigprofiler`,  the returned object is also of the `SummarizedExperiment`. The scores will be returned as a part of the colData. 

Below, we compare the enrichment scores for the ZAK_RISK_16, Anderson_42, and Anderson_OD_51 signatures. 


```{r show scores, message = FALSE}
## New colData entries from the Profiler
DT::datatable(as.data.frame(colData(ssgsea_result))[,2:5])
```

## Visualization with TBSignatureProfiler Plots{.tabset}

### Heatmap with all Signatures

Commonly, enrichment scores are compared across signatures by means of a heatmap combined with clustering methods to group samples and/or scores. The `signatureHeatmap` function uses the information from the score data to visualize changes in gene expression across samples and signatures (or genes, if only one signature is selected). 

Here, the columns of the heatmap represent samples, and rows represent signatures. As we move across the colums, we see different patterns of gene expression as indicated by the varying color and intensity of individial rectangles. In the top bar, the solid red represents a sample is HIV infected only, and solid blue indicates that the sample is both HIV and TB infected. In the gradient area of the heatmap, the scaled scores are associated with either up-regulated or down-regulated genes. A cluster of samples near the bottom of the heatmap reveals that some signatures are inversely associated with TB/HIV identification, as their pheotypic mapping for lower/higher scores is nearly the opposite of most of the other signatures.  

```{r heatmaps all, message = FALSE, fig.height = 8, fig.width = 10}
# Colors for gradient
colors <- RColorBrewer::brewer.pal(6, "Spectral")
col.me <- circlize::colorRamp2(seq(from = -2, to = 2, 
                                   length.out = 6), colors)

signatureHeatmap(ssgsea_result, name = "Heatmap of Signatures, 
                 ssGSEA Algorithm", 
                 signatureColNames = names(TBsignatures),
                 annotationColNames = "Disease",
                 scale = TRUE,
                 showColumnNames = FALSE,
                 choose_color = col.me)
```


### Boxplots of Scores, All Signatures

Another method of visualization for scores is that of boxplots. When multiple signatures in the input data are to be compared, the `signatureBoxplot` function takes the scores for each signature and produces an individual boxplot, with jittered points representing individual sample scores. For this specific example, it is clear that some signatures do a better job at differentiating the TB/HIV and HIV only samples than others, as seen by overlapping or separate spreads of the adjacent boxplots.

```{r Boxplots all, message = FALSE, results = 'hide', fig.height = 9, fig.width=12}
signatureBoxplot(inputData = ssgsea_result, 
                 name = "Boxplots of Signatures, ssGSEA", 
                 signatureColNames = names(TBsignatures),
                 annotationColName = "Disease", rotateLabels = FALSE)
```


### Boxplots of Scores, Individual Signatures {.tabset}
If only one boxplot of a signature is desired, then that signature alone should be specified in `signatureColNames`. Otherwise, an array of plots for all signatures will be produced.

```{r Boxplots indiv, results = "asis", message = FALSE}
for (i in names(TBsignatures)){

  cat("####", i, "\n")

  print(signatureBoxplot(ssgsea_result, name = i, signatureColNames = i,
                 annotationColName = c("Disease")))
  
  cat("\n\n")
}

```

### Heatmaps for Individual Signatures {.tabset}

The `signatureGeneHeatmap` function produces heatmaps that highlight a single selected signature. The resulting plots feature samples on the columns, and the genes in the signature on the rows. The annotation rows at the top are related to both the disease phenotype and to the signature score itself.  The gradient of the heatmap is created using the gene expression values in the assay specified by the `useAssay` parameter. Here, we observe how the log(CPM) values for specific genes relate to the signanture score for each sample.

```{r Heatmaps indiv, results = "asis", message = FALSE}
for (i in names(TBsignatures)){

  cat("####", i, "\n")

  signatureGeneHeatmap(inputData = ssgsea_result, useAssay = "logcpm",
                       TBsignatures[[i]],
                       name = i, signatureColNames = i, 
                       annotationColNames = c("Disease"),
                       showColumnNames = FALSE)
  
  cat("\n\n")
}

```

### Table with T-tests & AUC 
The `TableAUC` function creates a table of useful information regarding the scored  signatures. First, a 2-sample t-test is conducted on the scores with the TB/HIV status as the reponse variable. This is intended to give one metric of whether the signature is a valuable identifier of the disease phenotype. The log-scaled p-values are provided for easier means of comparison. 

The table also gives the AUC values for the signature scores, along with confidence intervals derived from bootstrapping. Most AUC estimates are fairly high.
```{r AUC table, message = FALSE}
tableAUC(ssgsea_result, 
         annotationColName = "Disease", 
         signatureColNames = names(TBsignatures),
         num.boot = 100, 
         pb.show = FALSE)
```

### Boxplots for the bootstrapped AUCs
We can visualize the bootstrapped AUCs for the scored signatures by creating a colllection of boxplots. 

```{r BS Boxplots, message = FALSE}
compareBoxplots(ssgsea_result, annotationColName = "Disease",
                signatureColNames = names(TBsignatures),
                pb.show = FALSE)
```


### ROC plots for all signatures with 95% CI bands
The `signatureROCplot_CI` function plots the ROC curves for signature scores in separate plots, along with CI bands for the specified level of confidence. The `signatureROCplot` function is similar, but does not include confidence interval bands.

Note that, in some cases, signatures will be positive identifiers of TB whereas others are negative identifiers, hence some ROC curves will be below the chance line.
 
```{r ROC all, message = FALSE, fig.height = 9, fig.width = 12}
signatureROCplot_CI(inputData = ssgsea_result,
                   signatureColNames = names(TBsignatures),
                   annotationColName = "Disease")

```

### Separate ROC plots, 95% CI bands {.tabset}
```{r ROC indiv, results = 'asis', message = FALSE}
for (i in names(TBsignatures)){
  
  cat("####", i, "\n")
  
  print(signatureROCplot_CI(inputData = ssgsea_result, 
                   signatureColNames = i,
                   annotationColName = "Disease",
                   name = paste("ROC plot,", i, sep = " ")))
  
  cat("\n\n")
}
```

## Signature Evaluation with Logistic Regression

Another method of signature evaluation featured in the TBSignatureProfiler package is available with the `SignatureQuantitative` function. 

During the training process, we bootstrap the samples, cross-validate the logistic regression predicition of the TB?HIV status of each sample, and calculate the validation set AUCs from each cross-validation iteration. In theory, if a signature is a useful predictor of status, it should have a higher average AUC from these logistic regression bootstraps. We then create a boxplot of AUC for each signature, which provides a clear comparison between the signatures. 

```{r SigEVAL, message = FALSE}
### Make an additional binary indicator for signature evaluation
hivtb_data$BinaryTB <- as.numeric(hivtb_data$Disease)-1

## We can normalize the data and evaluate the signatures
hivtb_norm <- deseq2_norm_rle(assay(hivtb_data, "counts"))

quantitative.result <- SignatureQuantitative(df.input = hivtb_norm,
                       target.vec.num = colData(hivtb_data)$BinaryTB,
                       signature.list = TBsignatures,
                       signature.name.vec = names(TBsignatures),
                       num.boot = 10,
                       pb.show = FALSE)

DT::datatable(round(quantitative.result$df.auc.ci, 4),
              options = list(scrollX = T, pageLength = 10), 
              rownames = F)
DT::datatable(round(quantitative.result$df.sensitivity.ci, 4),
              options = list(scrollX = T, pageLength = 10), 
              rownames = F)
DT::datatable(round(quantitative.result$df.specificity.ci, 4),
              options = list(scrollX = T, pageLength = 10), 
              rownames = F)
```
